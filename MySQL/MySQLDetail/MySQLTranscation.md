# MySQL事务隔离

## MySQL并发带来的问题
 首先，由于MySQL各种事务并发运行，就会导致各种各样的问题
 - 脏读（dirty read）：
    脏读的意思就是，如果事务A首先访问数据，并进行了更改，然后事务B 这个时候也访问了数据，那么事务B 读取的数据就是事务A 更改之后的数据，如果事务A 在事务B读取完毕之后进行了roolback操作的话，那么事务B 读取该数据的数值就是不准确的，这个就叫做脏读。
 - 丢失修改（lost modify）：
    丢失修改的意思是，如果事务A 首先访问了data_A数据，同时事务B 也访问了data_A数据，然后在事务A 修改了data_A数据之后，事务B也紧随其后修改了data_A的数据，那么第一个事务修改的结果就会丢失，这个就叫做丢失修改。比如：事务A 读取表中的数据A=10，事务B 读取表中的数据A = 10.然后A开始修改数据，A = A -1 ，然后事务B 也开始修改A 的数据，A =A -2 ，这样事务A 的修改就被丢失了。
-  不可重复读（unrepeatableread）：
    指在同一个事务当中，两次读同一条数据的返回的值不一样。比如，在事务A 当中，第一次读取的A = 10，同时，开启事务B，事务B 对 A 的值进行修改，set A = 11, 然后在事务A 第二次读取A 的值得时候，就会发生变化，因此成为不可重复读，
-   幻读（phantom read）:
    幻读和不可重复读类似，不过是事务A读取了几行数据，然后事务B 插入了一些数据，在事务A 紧接着的查询中，发现数据多了几条，所以称为幻读。


**不可重复读和幻读的主要区别是，不可重复读是修改数据，幻读是删除或者增加数据**


为了应对并发带来的各种问题，于是SQL定义了四个隔离级别。

## 事务隔离级别

- READ-UNCOMMITED(读取未提交):最低的隔离级别，允许读取没有提交的数据变更，可能会导致脏读，幻读，不可重复读。
  
- READ-COMMITED(读取已提交):允许读取并发事务已经提交的数据，可以阻止脏读，但是不能阻止幻读和不可重复读。

- REPEATABLE-READ(可重复读):对同一个字段多次读取的结果是一致的，除非数据是被自己本身的事务所修改，可以阻止脏读和不可重复读，但是可能会发生幻读。
  
- SERIALIZABLE(可串行化):最高的 隔离级别，完全服从ACID隔离级别，所有事物依次执行，事物之间不可能产生干扰。全部都能防止。会在读取的每一行都加锁。66666

**MYSQL 默认采取的是RR，即可重复读**