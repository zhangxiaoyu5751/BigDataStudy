
- [MySQL事务隔离](#mysql%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb)
  - [MySQL并发带来的问题](#mysql%e5%b9%b6%e5%8f%91%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%97%ae%e9%a2%98)
  - [事务隔离级别](#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab)
  - [MySQL事务实现](#mysql%e4%ba%8b%e5%8a%a1%e5%ae%9e%e7%8e%b0)
    - [事务的特点：](#%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e7%82%b9)
    - [原子性的实现](#%e5%8e%9f%e5%ad%90%e6%80%a7%e7%9a%84%e5%ae%9e%e7%8e%b0)
    - [持久性的实现](#%e6%8c%81%e4%b9%85%e6%80%a7%e7%9a%84%e5%ae%9e%e7%8e%b0)
    - [隔离性的实现](#%e9%9a%94%e7%a6%bb%e6%80%a7%e7%9a%84%e5%ae%9e%e7%8e%b0)
      - [MYsql 已经在rr情况下解决了幻读的问题，那么是怎么解决的呢？](#mysql-%e5%b7%b2%e7%bb%8f%e5%9c%a8rr%e6%83%85%e5%86%b5%e4%b8%8b%e8%a7%a3%e5%86%b3%e4%ba%86%e5%b9%bb%e8%af%bb%e7%9a%84%e9%97%ae%e9%a2%98%e9%82%a3%e4%b9%88%e6%98%af%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3%e7%9a%84%e5%91%a2)
  - [innodb 和 myisam区别](#innodb-%e5%92%8c-myisam%e5%8c%ba%e5%88%ab)
    - [mvcc 和 乐观锁的区别](#mvcc-%e5%92%8c-%e4%b9%90%e8%a7%82%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab)

# MySQL事务隔离


## MySQL并发带来的问题
 首先，由于MySQL各种事务并发运行，就会导致各种各样的问题
 - 脏读（dirty read）：
    脏读的意思就是，如果事务A首先访问数据，并进行了更改，然后事务B 这个时候也访问了数据，那么事务B 读取的数据就是事务A 更改之后的数据，如果事务A 在事务B读取完毕之后进行了roolback操作的话，那么事务B 读取该数据的数值就是不准确的，这个就叫做脏读。
 - 丢失修改（lost modify）：
    丢失修改的意思是，如果事务A 首先访问了data_A数据，同时事务B 也访问了data_A数据，然后在事务A 修改了data_A数据之后，事务B也紧随其后修改了data_A的数据，那么第一个事务修改的结果就会丢失，这个就叫做丢失修改。比如：事务A 读取表中的数据A=10，事务B 读取表中的数据A = 10.然后A开始修改数据，A = A -1 ，然后事务B 也开始修改A 的数据，A =A -2 ，这样事务A 的修改就被丢失了。
-  不可重复读（unrepeatableread）：
    指在同一个事务当中，两次读同一条数据的返回的值不一样。比如，在事务A 当中，第一次读取的A = 10，同时，开启事务B，事务B 对 A 的值进行修改，set A = 11, 然后在事务A 第二次读取A 的值得时候，就会发生变化，因此成为不可重复读，
-   幻读（phantom read）:
    幻读和不可重复读类似，不过是事务A读取了几行数据，然后事务B 插入了一些数据，在事务A 紧接着的查询中，发现数据多了几条，所以称为幻读。


**不可重复读和幻读的主要区别是，不可重复读是修改数据，幻读是删除或者增加数据**


为了应对并发带来的各种问题，于是SQL定义了四个隔离级别。

## 事务隔离级别

- READ-UNCOMMITED(读取未提交):最低的隔离级别，允许读取没有提交的数据变更，可能会导致脏读，幻读，不可重复读。
  
- READ-COMMITED(读取已提交):允许读取并发事务已经提交的数据，可以阻止脏读，但是不能阻止幻读和不可重复读。

- REPEATABLE-READ(可重复读):对同一个字段多次读取的结果是一致的，除非数据是被自己本身的事务所修改，可以阻止脏读和不可重复读，但是可能会发生幻读。
  
- SERIALIZABLE(可串行化):最高的 隔离级别，完全服从ACID隔离级别，所有事物依次执行，事物之间不可能产生干扰。全部都能防止。会在读取的每一行都加锁。66666

**MYSQL 默认采取的是RR，即可重复读**


## MySQL事务实现
### 事务的特点：
- 原子性
    什么叫做原子性？一个事务必须被视为不可分割的最小的单位，一个事务中的操作要么全部执行成功提交，要么就全部失败回滚，不可能只执行其中的部分，这就叫做原子性
- 一致性
    一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。 比如说借钱，要么A少了同时B多了，要么A没借。

    原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见
- 隔离性
  管理多个并发读写请求的访问顺序，包括穿行和并行
- 持久性
    事务一旦提交，他的修改就会永远保存在数据库中，就算是系统崩溃也不会造成数据丢失。

那么是如何实现事务的各个特点的呢？
靠的是 日志文件，锁， 和MVCC


### 原子性的实现
通过回滚实现原子性的操作，那么如何进行回滚呢，就是借助undo log 日志文件进行回滚。
- 每条操作指令都会伴随着一条undo log日志生成，并且日志是优先于数据持久化到磁盘上
- 然后进行回滚操作的实质就是根据日志进行逆向操作，比如delete的逆向操作就是insert等。

### 持久性的实现
首先了解下mysql的存储机制，mysql的表数据是存储到磁盘上的，同时为了提高性能，提供了缓冲池 buffer pool。
读数据的时候，首先会从缓冲池当中来取数据，如果缓冲池没有，就从磁盘上读取然后放入缓冲池。
写数据 会首先写到缓冲池，缓冲池会定期同步到磁盘上。

如果在写数据的时候，mysql突然宕机，我们的数据已经提交了，但是还是存在于缓冲池当中，还没来得及进行磁盘持久化，该怎么办呢？

当我们在一个事务中尝试对数据进行修改的时候，他会首先吧数据从磁盘上读入内存，然后更新内存中的数据，同时生成一条 redo log日志写入日志缓存，当事务提交的时候，会把日志flush到文件当中，然后吧内存中的数据更新到磁盘上。在发生错误后，数据库重启的时候，会从redo日志当中找到还没有更新到数据库磁盘当中的日志 重新执行来满足事务的持久性。
```
在 InnoDB 中，重做日志都是以 512 字节的块的形式进行存储的，同时因为块的大小与磁盘扇区大小相同，所以重做日志的写入可以保证原子性，不会由于机器断电导致重做日志仅写入一半并留下脏数据。

（1）redo log 的存储是顺序存储，而缓存同步是随机操作。

（2）缓存同步是以数据页为单位的，每次传输的数据大小大于redo log。
```
### 隔离性的实现
mysql 这边提供了4种隔离级别，分别是 read commited 读取未提交， read commited 读取已提交，reapeatable read 可重复读，SERIALIZABLE 可串行化。那么这几种都是怎么实现的呢？简单来说 是利用MVCC + 锁来实现的。
- 读取未提交
首先，读取未提交隔离级别是不加锁的，所以性能是最好的，没有加锁，解锁带来的性能的开销，所以没有解决任何问题
- 串行化
  读的时候加共享锁，也就是其他事物可以并发读，但是不能写。写的时候加排他锁，其他事物不能并发写也不能并发读。
- 可重复读 
  为了实现可重复读，mysql采用了mvcc(多版本并发控制)的方式。MVCC版本的生成时机 read commit 生成的时机是在每一次select。而可重复读是第一次的select。
  我们在数据库表中看到的一行记录可能实际上存在很多个版本，每个版本的记录除了数据本身之外，还有表示版本的字段，他在事务开始的时候向系统申请，按照时间顺序递增，可重复读是在事务开始的时候生成一个当前事务全局性的快照，每次读数据的是都都从快照里面读数据，
  如果是当前事务内的更新，是可以读到的，
  如果版本没有提交的话  不能读到
  如果版本提交的话 但是却在快照生成的后面，读不到
  如果版本提交，但是生成在快照之前，是可以读到的。
  所以可重复读实现的快照是在刚开始的时候，所以在另外一个事务内修改，在本事务读不到。

- 读取提交 
  生成的快照是在每次执行语句的时候都会重新生成一次快照，所以会出现不可重复读的局面。

#### MYsql 已经在rr情况下解决了幻读的问题，那么是怎么解决的呢？

是mysql采用锁来解决了并发写和幻读的问题，通过 行锁和间隙锁的组合 叫NEXT-KEY锁 来实现的


https://juejin.im/post/5e81fcbae51d4546bb6f33e8


## innodb 和 myisam区别
- innodb支持事务，myisam不支持事务。
- innodb有行级锁，myisam只支持表级锁，一个更新会锁住整张表。
- innodb支持外键，myisam不支持。
- innodb是聚簇索引，myisam是非聚簇索引。


悲观锁（Pessimistic Lock）
当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。

乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。

https://juejin.im/post/5b4977ae5188251b146b2fc8


### mvcc 和 乐观锁的区别


在数据库中，并发控制是指在多个用户/进程/线程同时对数据库进行操作时，如何保证事务的一致性和隔离性的，同时最大程度地并发。

当多个用户/进程/线程同时对数据库进行操作时，会出现3种冲突情形：
- 读-读，不存在任何问题
- 读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等。
- 写-写，可能丢失更新
  

  要解决冲突，一种办法是是锁，即基于锁的并发控制，比如2PL，这种方式开销比较高，而且无法避免死锁。
  
  多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读
  
  乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。多版本并发控制可以结合基于锁的并发控制来解决写-写冲突，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。