# MySQL调优

## 优化查询访问
查询性能低下最根本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，我们通过以下两个步骤分析总是很有效：
* 确认应用程序是否检索大量超过需要的数据，可能意味着访问太多的行，也可能是太多的列
* 确认服务器层是否在分析大量需要的行


### 是否向数据库请求了不需要的数据

#### 查询不需要的记录
    MySQL 查询时返回全部结果集 在进行计算，所以如果不必要的话 在查询后面加上limit

#### 多表关联时 返回全部列
    切忌select *，需要进行认真考虑是否需要返回全部的列。

#### 重复查询相同的记录
    可以使用缓存。

### 是否在扫描额外的记录
    如果发现查询需要扫描大量的数据但是却只是返回很少的行，那么通常可以采用的方法有：
-   使用索引覆盖扫描，把需要的列都放到索引中，这样就不必回表
-   改变表结构
-   重写复杂的查询，让优化器能够以更优化的方式执行这个查询


## 当我们向Mysql发送请求的时候，Mysql原理

-   客户端发送一条查询给服务器
-   服务器先检查查询缓存，如果命中了缓存，立刻返回存储在缓存中的结果，否则进入下一阶段
-   服务器端进行SQL解析 预处理 再由优化器生成对应的执行计划
-   Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询
-   返回结果给客户端 
**Mysql客户端和服务器之间是半双工的，一个时刻只能由一方发送给另一方。不能同时发送，同时，发送的时候不能停下来**

  

## Mysql优化器可能选择错误的执行计划 
- 统计信息不准确，MYSql 以来存储引擎提供的统计信息来评估成本，但是有的存储引擎提供的信息是准确的的，但是有的偏差就可能非常大，比如innodb的mvcc架构
- 执行计划中的成本估算不等同于实际执行的成本，比如某个执行计划虽然读取更多的页面，但是他的成本（比如是顺序读，或者是存储在内存中）却更小。
- MYSQL的最优和你想想的最优可能不一样。你可能希望执行计划尽可能的时间短，但是mysql是基于成本模型选择出的最优的执行计划
- mysql不考虑并发的查询，所以可能会影响当前的查询速度
- mysql 可能无法估算所有可能的执行计划
- mysql不会考虑不受控制操作的成本 比如自定义函数
- mysql 有时候也会给予一些固定的规则进行优化，可能有更好的方法，但是仍然根据固定的规则进行优化

## MYSQL优化器使用了非常多的优化策略来生成一个最优的执行计划

- 重新定义表的管理按顺序
- 优化MIN（）或者 max（）函数
- 提前终止查询 比如使用limit 的时候
- 优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）
- 等等
  

## MYSQL 性能优化建议

### schema设计和数据类型优化

选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会越快，占用更少的磁盘 内存 处理需要的cpu也越少。

### 创建高性能索引

#### MySQL不会使用索引的情况：非独立的列
    “独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：
    select * from where id + 1 = 5
    我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，使用函数是同样的道理。
### 前缀索引
    如果列很长的话 通常可以索引开始的部分字符，这样节省索引空间，提高索引效率
### 多列索引和索引顺序
    多列索引并不意味着能够提高性能，如果能够采取一个联合索引以及调整索引的顺序更为重要
    如果吧选择性高的索引放到前面的话 这样通过第一个字段就能筛掉大部分数据， 索引选择性是指不重复的索引值和数据表的总记录数的比值
### 避免多个范围条件
    如果一个语句里面有多个范围条件的话 只能选择一个索引，不能同时使用
### 覆盖索引

### 使用索引扫描来排序
    在设计索引时候，一个索引既能够满足排序 又能够满足查询 是最好的
    只有当索引的列顺序和order by的顺序完全一致，才能使用索引对结果排序
    如果查询关联多张表，那么只有order by 引用的字段全部是第一张表的时候，才能使用索引作为拍戏
### 删除冗余和重复索引 以及长期没有使用的索引

## 特定查询优化

### 优化count()
- count(列) 查找列值非空， 不会统计NULL
   - count(*) 统计行数。

### 优化关联查询

  - 确保on 或者using的列上有索引。在创建索引的时候要考虑到关联顺序，当A表和B表用c字段进行关联的时候，如果优化器关联的顺序是A ，B,那么就不需要在A表的对应列上创建索引，一般来说，只需要在关联顺序的第二张表的相关列上创建索引 原因是 MYSQL 对关联的智行是嵌套循环关联操作，关联顺序是A,B， B是内层循环，能够加速查询
  - 确保groupby和orderby的表达式只涉及到一个表中的列 ，这样才有可能适用索引优化

### 优化limit 查询
    如果偏移量非常大的时候，比如limit 1000，20 这样 前面的1000条全部被舍弃，代价很高
    优化这种查询最简单的方法就是使用覆盖索引，筛选掉部分的列之后再做一次关联，对于偏移量很大的时候 这样做效率很高 比如：
```
    SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;
```
    可以改写成：
```
        SELECT film.film_id,film.description
        FROM film INNER JOIN (
            SELECT film_id FROM film ORDER BY title LIMIT 50,5
        ) AS tmp USING(film_id);
```
或者是说记录上次读取数据的位置
```
SELECT id FROM t LIMIT 10000, 10;
```
改写成
```
SELECT id FROM t WHERE id > 10000 LIMIT 10;
```

### 优化union
    处理union的策略是先创建临时表，然后将各个查询结果放到临时表中，最后再做查询，如果很多策略在union查询的时候没有很好的办法的时候，就需要将where，limit ，order by 下推到各个子查询中。

    除非一定要服务器去重，否则就是用union all 如果不加all。需要对临时表做唯一性检查，代价非常高。
